{
    "BinaryTree": {
        "prefix": "!tree",
        "body": [
            "struct TreeNode {",
            "    int val;",
            "    TreeNode *left;",
            "    TreeNode *right;",
            "    TreeNode() : val(0), left(nullptr), right(nullptr) {}",
            "    TreeNode(int v) : val(v), left(nullptr), right(nullptr) {}",
            "    TreeNode(int v, TreeNode *left, TreeNode *right)",
            "        : val(v), left(left), right(right) {}",
            "};\n",
            "TreeNode *makeTree(std::vector<int> values) {",
            "    if (values.empty()) {",
            "        return nullptr;",
            "    }",
            "    std::vector<TreeNode *> nodes(values.size(), nullptr);",
            "    TreeNode *root = new TreeNode(values[0]);",
            "    nodes[0] = root;",
            "    for (int i = 1; i < values.size(); i++) {",
            "        if (values[i] == -1) {",
            "            continue; // -1 is used to denote null nodes.",
            "        }",
            "        TreeNode *curr = new TreeNode(values[i]);",
            "        nodes[i] = curr;",
            "        //     0       Link parent to this child.",
            "        //    / \\      Left-side children have odd indices, while",
            "        //   1   2     right-side children have even indices.",
            "        //  / \\ / \\    The parent's index is always floor((n-1)/2).",
            "        // 3  45   6",
            "        int parent_idx = (i - 1) / 2;",
            "        if (i % 2 == 1) {",
            "            nodes[parent_idx]->left = nodes[i];",
            "        } else {",
            "            nodes[parent_idx]->right = nodes[i];",
            "        }",
            "    }",
            "    return root;",
            "}\n",
            "bool is_same(TreeNode *tree1, TreeNode *tree2) {",
            "    if (tree1 == nullptr) {",
            "        return tree2 == nullptr;",
            "    }",
            "    if (tree2 == nullptr) {",
            "        return false;",
            "    }",
            "    if (tree1->val != tree2->val) {",
            "        return false;",
            "    }",
            "    return is_same(tree1->left, tree2->left) &&",
            "           is_same(tree1->right, tree2->right);",
            "}"
        ],
        "description": "Inserts a definition of a binary tree data structure in C++"
    },
    "DIRS": {
        "prefix": "!directions",
        "body": [
            "const std::vector<std::vector<int>> DIRS = {{1, 0}, {0, 1}, {-1, 0}, {0, -1}};"
        ],
        "description": "Unit directions on a 2D grid"
    },
    "LeetcodeSolutionCpp": {
        "prefix": "!lc",
        "body": [
            "#include <iostream>\n",
            "// Runtime complexity: ",
            "// Auxiliary space complexity: ",
            "// Subjective level: ",
            "// Solved on: ${CURRENT_YEAR}-${CURRENT_MONTH}-${CURRENT_DATE}",
            "class Solution {",
            "public:",
            "    ${1:int} ${2:solve}(${3:int} ${4:input}) {",
            "        $1 ans = {};",
            "        // TODO$0",
            "        return ans;\n",
            "    }",
            "};\n",
            "int main() {",
            "    struct Testcase {",
            "        $3 $4;",
            "        $1 expected;",
            "    };",
            "    Testcase testcases[] = {",
            "        {${5}},",
            "    };",
            "    Solution s{};",
            "    int numGood = 0, numBad = 0;",
            "    for (Testcase& tc: testcases) {",
            "        auto actual = s.$2(tc.$4);",
            "        if (actual != tc.expected) {",
            "            std::cout << \"Testcase \" << tc.$4 << \" failed. Got: \" << actual",
            "                << \", want: \" << tc.expected << \"\\n\";",
            "            ++numBad;",
            "        } else {",
            "            ++numGood;",
            "        }",
            "    }",
            "    std::cout << (numBad == 0 ? \"[OK]\" : \"[FAIL]\") << \" \"",
            "        << numGood << \"/\" << (numBad + numGood) << \" testcases passed successfully.\\n\";",
            "}"
        ],
        "description": "Leetcode challenge solution in C++"
    },
    "Mod_1e9+7": {
        "prefix": "!MOD",
        "body": [
            "constexpr int MOD = 1'000'000'007;"
        ],
        "description": "1e9+7, a popular modulo divisor in competitive programming."
    },
    "Starter Template": {
        "prefix": "!st",
        "body": [
            "#include <iostream>\n",
            "int main() {",
            "\t$0",
            "}"
        ],
        "description": "A simple template for a short C++ program"
    },
    "VectorToString": {
        "prefix": "!vectostring",
        "body": [
            "template<typename T>",
            "std::string vectorToString(std::vector<T> vec) {",
            "    std::string separator = \"\";",
            "    std::stringstream ss;",
            "    ss << \"[\";",
            "    for (const auto& elem: vec) {",
            "        ss << separator << elem;",
            "        separator = \", \";",
            "    }",
            "    ss << \"]\";",
            "    return ss.str();",
            "}"
        ],
        "description": "Converts any C++ vector to a string"
    }
}
